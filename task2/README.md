# Task 2  

## Описание  
Данный набор программ реализует базовые численные алгоритмы и работу со вводом/выводом в языке C.  
Все задачи выполнены в рамках домашнего задания №2 курса *«Практикум на ЭВМ 2025/2026»*.  

---

## Структура проекта
```
task2/
├── task2_1.c      # Квадратный корень методом Ньютона
├── task2_2_1.c    # Вычисление значения многочлена (метод Горнера)
├── task2_2_2.c    # Вычисление многочлена и его производной
├── task2_3.c      # Итеративное и рекурсивное вычисление чисел Фибоначчи
├── task2_4.c      # Разбор вещественной константы (аналог strtod)
├── task2_5.c      # Удаление всех вхождений последнего слова в списке
├── task2_6.c      # Операции для дерева поиска
├── task2_7.c      # Простой калькулятор с рекурсивным спуском
└── README.md      # (этот файл)
```

---

## Компиляция  

Для сборки всех программ используйте **gcc**:
```bash
gcc task2_1.c   -o task2_1
gcc task2_2_1.c -o task2_2_1
gcc task2_2_2.c -o task2_2_2
gcc task2_3.c   -o task2_3
gcc task2_4.c   -o task2_4
gcc task2_5.c   -o task2_5
gcc task2_6.c   -o task2_6
gcc task2_7.c   -o task2_7
```

---

## Описание задач и функций

### **task2_1.c — Метод Ньютона для квадратного корня**
**Основная функция:** 
```c
double sqrt_newton(double x, double eps);
```
**Описание:** Реализует вычисление квадратного корня числа `x` методом Ньютона с точностью `eps`.  
**Ввод:** значения `eps`, затем последовательность чисел `x`.  
**Вывод:** приближённые значения √x, ошибки печатаются в `stderr`.

---

### **task2_2_1.c — Вычисление многочлена (метод Горнера)**
**Основная функция:** 
```c
double horner(double x, double coeffs[], int n);
```
**Описание:** вычисляет значение многочлена степени `n-1` при заданном `x` по методу Горнера.  
**Ввод:** сначала `x`, затем коэффициенты `a0, a1, ..., an`.  
**Вывод:** значение многочлена.

---

### **task2_2_2.c — Многочлен и его производная**
**Основные функции:** 
```c
double horner_poly(double x, double coeffs[], int n);
double horner_derivative(double x, double coeffs[], int n);
```
**Описание:** 
- первая функция вычисляет значение многочлена в точке `x`;  
- вторая — значение его производной в той же точке.  
**Ввод:** `x`, затем коэффициенты.  
**Вывод:** на первой строке — значение многочлена, на второй — его производной.

---

### **task2_3.c — Числа Фибоначчи**
**Основные функции:** 
```c
long long fib_iterative(int n);
long long fib_recursive(int n);
```
**Описание:** 
- `fib_iterative` вычисляет n-е число Фибоначчи итеративно;  
- `fib_recursive` — рекурсивно.  
**Ввод:** последовательность целых чисел `n`.  
**Вывод:** для каждого `n` выводятся оба результата.  
Ошибки (например, отрицательные индексы) печатаются в `stderr`.

---

### **task2_4.c — Собственная функция str2double**
**Основная функция:** 
```c
double str2double(char str[]);
```
**Описание:** выполняет ручное преобразование строкового представления числа (включая знак, дробную и экспоненциальную часть) в `double`, без использования `math.h` и `strtod`.  
**Дополнительная функция:** 
```c
double pow10_int(int exp);
```
Реализует возведение 10 в степень `exp` без стандартных библиотек.  
**Обработка ошибок:** 
- некорректные форматы (`3.4E`, `..2`, `12L` и т.д.) → сообщение в `stderr`;  
- допустимы формы `3.14`, `-0.5`, `2.3E-2`, `.7` и `5.`.

---

### **task2_5.c — Удаление всех вхождений последнего слова**
**Основные структуры и функции:**
```c
typedef struct Node {
    char *word;
    struct Node *next;
} Node;

Node* parse_string_to_list(const char *input);
void remove_all_occurrences(Node **head, const char *target_word);
void print_list(Node *head);
```
**Описание:**  
Программа считывает строку, разбивает её на слова и формирует односвязный список. Затем определяет последнее слово и удаляет все его предыдущие вхождения в списке.  
**Ввод:** строка из нескольких слов.  
**Вывод:** исходная строка без повторных вхождений последнего слова.  
**Пример:**  
```
Ввод:  cat dog cat dog
Вывод: cat dog
```

---

### **task2_6.c — Бинарное дерево поиска**
**Основные функции:**
```c
TreeNode* insert(TreeNode *root, int key);
TreeNode* delete(TreeNode *root, int key);
int search(TreeNode *root, int key);
```
**Описание:**  
Реализованы операции с бинарным деревом поиска (BST):  
- `+N` — вставка числа N,  
- `-N` — удаление числа N,  
- `?N` — проверка наличия числа N в дереве.  

**Ввод:** построчно команды `+`, `-`, `?` и числа.  
**Вывод:** для операции `?N` — строка "`N yes`" или "`N no`".  
**Особенности:** ручное управление памятью и рекурсивные функции.  

---

### **task2_7.c — Простой калькулятор (рекурсивный спуск)**
**Основные функции:**
```c
int expr(void);
int term(void);
int factor(void);
int power(void);
int number(void);
```
**Описание:**  
Программа реализует калькулятор на основе рекурсивного спуска с грамматикой:
```
<выражение> ::= <слагаемое> {(+|-) <слагаемое>}
<слагаемое> ::= <множитель> {(*|/) <множитель>}
<множитель> ::= <степень>
<степень> ::= <число> [^ <множитель>]
<число> ::= цифра | (<выражение>)
```
Поддерживаются операции `+`, `-`, `*`, `/`, `^` и скобки.  
Ошибки (деление на 0, отрицательная степень, синтаксис) обрабатываются с помощью `setjmp/longjmp`.  
**Ввод:** арифметическое выражение.  
**Вывод:** результат вычисления или сообщение `ОШИБКА!`.
