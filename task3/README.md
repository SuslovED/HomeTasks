# Task 3 — Разбор строки на слова, сортировка, блочное чтение

## Постановка задачи

Программа читает данные из `stdin` до достижения `EOF`.

Каждая **непустая** строка обрабатывается по алгоритму:

1. Считать строку (ввод читается блоками фиксированного размера, см. ниже).
2. Разбить строку на слова.

   **Простые слова** — последовательности символов:
   - латинские буквы `A-Z`, `a-z`
   - цифры `0-9`
   - символы: `$`, `_`, `/`, `.`

   **Специальные слова** — один из токенов:
   - `|`, `||`
   - `&`, `&&`
   - `;`
   - `>`, `>>`
   - `<`
   - `(`
   - `)`

   Дополнительные правила:
   - Между словами могут быть пробелы и табуляции, **но могут и отсутствовать**.
   - Для последовательностей специальных символов выбирается **максимально возможное** слово:
     - `>>>` → `>>` и `>`
     - `|||`
       → `||` и `|`
     - `&&&` → `&&` и `&`
   - Пример:
     - Вход: `cat|sort&&ls>>file`
     - Выделенные слова: `cat`, `|`, `sort`, `&&`, `ls`, `>>`, `file`

3. Для каждой строки, в которой нашлись слова, вывести:

   1) Количество слов.  
   2) Слова в **исходном порядке**, по одному в строке.  
   3) Ещё раз количество слов.  
   4) Те же слова в **лексикографическом порядке** (`strcmp`), по одному в строке.

Пустые строки и строки, в которых после разбора не осталось слов, **не выводят ничего**.

Ввод продолжается до достижения `EOF` (Ctrl+D / Ctrl+Z).

---

## Структура проекта

task3/  
├─ main.c      — L-граф, чтение, разбор токенов, работа с одним списком на строку  
├─ words.c     — реализация списка строк (динамический массив `char*`)  
├─ words.h     — интерфейс модуля списка строк  
└─ Makefile    — сборка проекта  

---

## Модуль списка строк (`words.h` / `words.c`)

Список слов реализован как динамический массив указателей `char **`:

- **`initList(StringList *list)`**  
  Инициализирует пустой список.

- **`addWord(StringList *list, char *word)`**  
  Добавляет слово в конец списка.  
  `word` — динамически выделенная строка (`malloc`/`realloc`), владение которой
  передаётся списку.  
  При ошибке выделения памяти слово освобождается, функция возвращает `-1`.

- **`finalizeList(StringList *list)`**  
  Гарантирует наличие завершающего `NULL` в конце массива `data`.  
  По возможности подрезает массив под фактический размер (`size + 1`).

- **`printList(const StringList *list)`**  
  Печатает:
  - длину списка (количество слов),
  - затем все слова по одному в строке.  
  Если список пуст — печатает `0` и перевод строки.

- **`sortList(StringList *list)`**  
  Сортирует слова по `strcmp` (лексикографически).  
  Используется сортировка вставками.  

- **`clearList(StringList *list)`**  
  Освобождает все строки и сам массив, обнуляет структуру.

Все динамические выделения памяти в этом модуле имеют соответствующие `free`.

---

## Основной модуль (`main.c`)

### Чтение входа (условие 3)

Ввод осуществляется **блоками фиксированной длины** `INPUT_BLOCK_SIZE`:

- Используется буфер `inputBlock[INPUT_BLOCK_SIZE]`.
- Функция `getSym()`:
  - при исчерпании буфера пытается прочитать `INPUT_BLOCK_SIZE` символов:
    `fscanf(stdin, "%Nc", inputBlock)` (формат формируется из `INPUT_BLOCK_SIZE`);
  - если полный блок прочитать не удалось, дочитывает оставшиеся символы до `EOF`;
  - возвращает следующий символ (0..255) или `EOF`.
- Весь разбор работает через `getSym()`, прямого посимвольного чтения в логике автомата нет.

Это соответствует требованию: чтение блоками фиксированной длины `N` с помощью `fscanf`
при поддержке строк произвольной длины.

### Разбор слов (L-граф)

Используется конечный автомат со состояниями:

- **Start** — между словами / в начале строки:
  - пропускает пробелы и табы;
  - обрабатывает:
    - `\n`: если есть слова — выводит результаты для строки и очищает список;
    - `EOF`: если есть слова — выводит результаты для последней строки; завершает;
    - простой символ → `Simple`;
    - `|` → `Pipe`;
    - `&` → `Amp`;
    - `>` → `Greater`;
    - `;`, `<`, `(`, `)` → отдельное специальное слово;
    - остальные символы игнорируются.

- **Simple** — внутри простого слова:
  - добавляет допустимые символы;
  - при разделителе/спецсимволе завершает слово и возвращается в `Start`.

- **Pipe** — уже прочитан `'|'`:
  - если следующий символ `'|'` → токен `||`,
  - иначе → токен `|`;
  - добавление слова в список, переход в `Start`.

- **Amp** — уже прочитан `'&'`:
  - если следующий `'&'` → токен `&&`,
  - иначе → токен `&`;
  - добавление слова, переход в `Start`.

- **Greater** — уже прочитан `'>'`:
  - если следующий `'>'` → токен `>>`,
  - иначе → токен `>`;
  - добавление слова, переход в `Start`.

Каждое слово (простое или специальное) накапливается во внутреннем буфере и затем
передаётся в список через вспомогательную функцию.

### Обработка строк

На `\n` или `EOF`:

- Если в текущем списке есть слова:
  1. `finalizeList(list)`
  2. `printList(list)` — вывод слов в исходном порядке
  3. `sortList(list)`
  4. `printList(list)` — вывод тех же слов в отсортированном порядке
  5. `clearList(list)`
- Если слов нет — ничего не выводится.

Пустые строки или строки только из пробелов/табов не порождают вывода.

---

## Сборка

Требуется `gcc` или `clang`.

Сборка:

    make

Запуск:

    ./task3

Очистка:

    make clean

---

## Примеры

### 1. Пайплайн без пробелов

Ввод:

    echo "cat|sort&&ls>>file" | ./task3

Вывод:

    7
    cat
    |
    sort
    &&
    ls
    >>
    file
    7
    &&
    >>
    cat
    file
    ls
    sort
    |

### 2. Последовательность `>>>`

Ввод:

    echo ">>>" | ./task3

Вывод:

    2
    >>
    >
    2
    >
    >>

---

## Проверка утечек памяти

### macOS (`leaks`)

    leaks --atExit -- ./task3 <<EOF
    cat|sort&&ls>>file
    >>>
    EOF

В конце отчёта должно быть:

    0 leaks for 0 total leaked bytes.

### Linux / Docker (`valgrind`)

    valgrind --leak-check=full --track-origins=yes ./task3 < input.txt

Ожидается:

    All heap blocks were freed -- no leaks are possible
    ERROR SUMMARY: 0 errors from 0 contexts

