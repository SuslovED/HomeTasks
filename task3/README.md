# Task 3 — Разбор строки на слова, сортировка, блочное чтение

## Постановка задачи

Программа читает данные из `stdin` до достижения `EOF`.

Каждая **непустая** строка обрабатывается по алгоритму:

1. Считать строку (ввод читается блоками фиксированного размера, см. ниже).
2. Разбить строку на слова:

   **Простые слова** — последовательности символов:
   - латинские буквы `A-Z`, `a-z`
   - цифры `0-9`
   - символы: `$`, `_`, `/`, `.`

   **Специальные слова** — один из токенов:
   - `|`, `||`
   - `&`, `&&`
   - `;`
   - `>`, `>>`
   - `<`
   - `(`
   - `)`

   Дополнительные правила:
   - Между словами могут быть пробелы и табуляции, **но могут и отсутствовать**.
   - Для последовательностей специальных символов выбирается **максимально возможное** слово:
     - `>>>` → `>>` и `>`
     - `|||`
       → `||` и `|`
     - `&&&` → `&&` и `&`
   - Пример:
     - Вход: `cat|sort&&ls>>file`
     - Выделенные слова: `cat`, `|`, `sort`, `&&`, `ls`, `>>`, `file`

3. Для каждой строки, в которой нашлись слова, вывести:

   1) Количество слов.  
   2) Слова в **исходном порядке**, по одному в строке.  
   3) Ещё раз количество слов.  
   4) Те же слова в **лексикографическом порядке** (`strcmp`), по одному в строке.

Пустые строки и строки, в которых после разбора не осталось слов, **не выводят ничего**.

Ввод продолжается до достижения `EOF` (Ctrl+D / Ctrl+Z).

---

## Структура проекта

```text
task3/
├─ main.c      # L-граф, чтение, разбор токенов, работа с одним списком на строку
├─ words.c     # реализация списка строк (динамический массив char*)
├─ words.h     # интерфейс модуля списка строк
└─ Makefile    # сборка проекта
```

##Модуль списка строк (words.h / words.c)

Список слов реализован как динамический массив указателей char **:

initList(StringList *list)
Инициализация пустого списка.

addWord(StringList *list, char *word)
Добавить слово в конец списка.
word — уже выделенная динамически строка (malloc/realloc),
владение памятью переходит списку.
При нехватке памяти слово освобождается, возвращается -1.

finalizeList(StringList *list)
Обеспечивает наличие завершающего NULL в конце массива data.
При возможности подрезает массив под фактический размер.

printList(const StringList *list)
Печатает:

длину списка,

затем все слова построчно.
Если список пуст — печатает 0 и перевод строки.

sortList(StringList *list)
Сортирует слова по strcmp (лексикографически).
Используется сортировка вставками.

clearList(StringList *list)
Освобождает все строки и сам массив, обнуляет структуру.

Все динамические выделения памяти в этом модуле имеют соответствующие освобождения.

##Основной модуль (main.c)
Чтение входа (условие 3)

Ввод осуществляется блоками фиксированной длины INPUT_BLOCK_SIZE:

Используется буфер inputBlock[INPUT_BLOCK_SIZE].

Функция getSym():

При опустошении буфера пытается прочитать INPUT_BLOCK_SIZE символов:

fscanf(stdin, "%Nc", inputBlock);


(формат строится через макрос по INPUT_BLOCK_SIZE).

Если прочитать полный блок не удалось, дочитывает оставшиеся символы до EOF.

Возвращает очередной символ (0..255) или EOF.

Основной код автомата работает только через getSym(), не читая посимвольно напрямую.

Это соответствует требованию: «Считывание необходимо производить блоками фиксированной длины N с помощью функции fscanf» при поддержке строк произвольной длины.

Разбор слов (L-граф)

Используется конечный автомат со следующими состояниями:

Start — между словами / в начале строки:

пропускаем пробелы и табы;

реагируем на:

\n — если есть слова, выводим (исходный список + отсортированный);

EOF — если есть слова, выводим последний список и завершаем;

простой символ → Simple;

| → Pipe;

& → Amp;

> → Greater;

;, <, (, ) → отдельное специальное слово;

остальные символы игнорируем.

Simple — внутри простого слова:

продолжаем, пока идут допустимые символы;

по разделителю/спецсимволу завершаем слово и переходим в Start.

Pipe — уже прочитан '|':

если следующий '|' → ||,

иначе → |.

Amp — уже прочитан '&':

если следующий '&' → &&,

иначе → &.

Greater — уже прочитан '>':

если следующий '>' → >>,

иначе → >.

Каждое слово (простое или специальное) набирается в буфере и добавляется в список через addWordFromBuf.

Обработка строк

На \n или EOF:

Если в текущем списке есть слова:

finalizeList(list),

printList(list) — исходный порядок,

sortList(list),

printList(list) — отсортированный порядок,

clearList(list).

Если слов нет — ничего не выводится.

Пустые строки (или строки только с пробелами/табами/мусором) не порождают вывода.

##Сборка

Нужен gcc или clang.

##make


Создаётся исполняемый файл:

./task3


Очистка:

make clean

##Примеры
1. Пример с пайплайном
echo "cat|sort&&ls>>file" | ./task3


Результат:

7
cat
|
sort
&&
ls
>>
file
7
&&
>>
cat
file
ls
sort
|

2. Пример с >>>
echo ">>>" | ./task3


Результат:

2
>>
>
2
>
>>

##Проверка утечек памяти
macOS (leaks)
leaks --atExit -- ./task3 <<EOF
cat|sort&&ls>>file
>>>
